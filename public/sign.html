<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üîê Gigi TON Wallet Signing</title>
  <script src="https://unpkg.com/@tonconnect/ui@latest"></script>
  <link rel="icon" href="/gigip2bot-logo.png" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Segoe UI", sans-serif;
      background-color: #0f0f0f;
      color: white;
      overflow: hidden;
    }
    canvas {
      position: fixed;
      z-index: 0;
    }
    .main {
      position: relative;
      z-index: 1;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    h1 {
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    #status {
      margin-top: 1rem;
      font-size: 1.1rem;
    }
    #disconnect {
      margin-top: 15px;
      background: #ff3333;
      color: #fff;
      border: none;
      padding: 10px 20px;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
    }
    #powered {
      position: absolute;
      bottom: 12px;
      font-size: 0.9rem;
      color: #aaa;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="main">
    <h1>üîê Gigi Wallet Signing (TON)</h1>
    <ton-connect id="ton-connect"></ton-connect>
    <button id="disconnect" onclick="disconnectWallet()">Disconnect</button>
    <div id="status">Waiting for wallet connection...</div>
    <div id="powered">‚ú® Powered by Gigi Labs</div>
  </div>

  <script>
    const connector = new TON_CONNECT_UI.TonConnectUI({
      manifestUrl: "https://gigi-wallet-signing.onrender.com/tonconnect-manifest.json",
      buttonRootId: "ton-connect"
    });

    connector.onStatusChange(wallet => {
      if (wallet) {
        document.getElementById("status").innerText = "‚úÖ Wallet connected!";
        playSound("connect");
        sendSignedTx();
      } else {
        document.getElementById("status").innerText = "‚ùå Wallet not connected.";
        playSound("disconnect");
      }
    });

    function disconnectWallet() {
      connector.disconnect();
    }

    function sendSignedTx() {
      const params = new URLSearchParams(window.location.search);
      fetch("http://34.203.188.151:5000/ton-webhook", {
        method: "POST",
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          user_id: params.get("user_id"),
          amount: params.get("amount"),
          to: params.get("to"),
          token: params.get("token"),
          tx_type: params.get("tx_type")
        })
      }).then(() => {
        document.getElementById("status").innerText = "‚úÖ Transfer confirmed! Webhook invoked!";
        playSound("confirm");
        alert("‚úÖ Webhook sent!");
      }).catch(() => {
        document.getElementById("status").innerText = "‚ùå Failed to contact server.";
      });
    }

    function playSound(type) {
      const sounds = {
        connect: "https://assets.mixkit.co/sfx/preview/mixkit-software-interface-start-2574.mp3",
        disconnect: "https://assets.mixkit.co/sfx/preview/mixkit-click-error-1110.mp3",
        confirm: "https://assets.mixkit.co/sfx/preview/mixkit-confirmation-tone-2867.mp3"
      };
      new Audio(sounds[type]).play();
    }

    // magical animated nodes
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let nodes = Array.from({ length: 50 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      dx: (Math.random() - 0.5) * 2,
      dy: (Math.random() - 0.5) * 2
    }));
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      nodes.forEach((node, i) => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;
        ctx.beginPath();
        ctx.arc(node.x, node.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = "#0ff";
        ctx.fill();
        for (let j = i + 1; j < nodes.length; j++) {
          let dist = Math.hypot(node.x - nodes[j].x, node.y - nodes[j].y);
          if (dist < 100) {
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.strokeStyle = "rgba(0,255,255,0.1)";
            ctx.stroke();
          }
        }
      });
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>