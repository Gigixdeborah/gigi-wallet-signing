<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gigi Labs | Connect EVM Wallet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/@walletconnect/web3modal@2.8.0/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to right, #0f0c29, #302b63, #24243e);
      color: white;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      overflow: hidden;
    }
    h1 {
      font-size: 28px;
      color: #00e0ff;
      margin-bottom: 30px;
      text-shadow: 0 0 15px #00e0ff;
    }
    button {
      padding: 14px 36px;
      font-size: 18px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px;
      transition: 0.3s ease-in-out;
    }
    #connectBtn { background: #00e0ff; color: #000; }
    #signBtn { background: #00ff95; color: #000; display: none; }
    #disconnectBtn { background: #ff4444; color: #fff; display: none; }
    footer {
      position: absolute;
      bottom: 10px;
      font-size: 14px;
      color: #aaa;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }
  </style>
</head>
<body>

<script>
  if (navigator.userAgent.toLowerCase().includes("telegram")) {
    const open = confirm("Telegram blocks wallet connections.\nOpen in Chrome?");
    if (open) {
      const url = encodeURIComponent(window.location.href);
      window.location.href = `https://t.me/share/url?url=${url}`;
    }
  }
</script>

<canvas id="bg"></canvas>
<h1>Connect Your EVM Wallet</h1>
<button id="connectBtn">üöÄ Connect Wallet</button>
<button id="signBtn">‚úÖ Sign Transaction</button>
<button id="disconnectBtn">‚ùå Disconnect</button>
<footer>‚ú® Powered by Gigi Labs</footer>

<script>
  const { EthereumProvider, Web3Modal } = window["@walletconnect/web3modal"];
  const { ethers } = window.ethers;

  const query = new URLSearchParams(window.location.search);
  const user_id = query.get("user_id");
  const amount = query.get("amount");
  const to = query.get("to");
  const projectId = "4c483f64603635192755f2324df4ec2";

  const metadata = {
    name: "Gigi Labs",
    description: "GigiP2Bot Web3 Wallet Connect",
    url: "https://gigi-wallet-signing.onrender.com",
    icons: ["https://gigi-wallet-signing.onrender.com/favicon.ico"]
  };

  const provider = new EthereumProvider({ projectId, metadata });
  const modal = new Web3Modal({ projectId });

  let signer, address;

  document.getElementById("connectBtn").onclick = async () => {
    await modal.openModal();
    await provider.connect();
    const web3Provider = new ethers.providers.Web3Provider(provider);
    signer = web3Provider.getSigner();
    address = await signer.getAddress();
    document.getElementById("signBtn").style.display = "inline-block";
    document.getElementById("disconnectBtn").style.display = "inline-block";
  };

  document.getElementById("disconnectBtn").onclick = async () => {
    await provider.disconnect();
    document.getElementById("signBtn").style.display = "none";
    document.getElementById("disconnectBtn").style.display = "none";
  };

  document.getElementById("signBtn").onclick = async () => {
    try {
      const tx = {
        to: to,
        value: ethers.utils.parseEther(amount)
      };
      const response = await signer.sendTransaction(tx);
      const hash = response.hash;

      await fetch("http://34.203.188.151:5000/evm-webhook", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id,
          wallet: address,
          to,
          amount,
          tx_type: "buy",
          token: "ETH",
          signed_tx: hash
        })
      });

      new Audio("https://assets.mixkit.co/sfx/preview/mixkit-game-bonus-reached-2065.mp3").play();
      alert("‚úÖ Transaction sent!\nTX Hash: " + hash);
    } catch (e) {
      alert("‚ùå Transaction failed or cancelled.");
    }
  };
</script>

<script>
  const canvas = document.getElementById("bg");
  const ctx = canvas.getContext("2d");
  let width, height;
  const dots = [];
  let mouseX = -1000, mouseY = -1000;

  function resizeCanvas() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }

  function createDot() {
    return {
      x: Math.random() * width,
      y: Math.random() * height,
      vx: (Math.random() - 0.5) * 1,
      vy: (Math.random() - 0.5) * 1,
      radius: 1 + Math.random() * 2
    };
  }

  function initDots() {
    for (let i = 0; i < 80; i++) dots.push(createDot());
  }

  function animate() {
    ctx.clearRect(0, 0, width, height);
    dots.forEach((dot, i) => {
      dot.x += dot.vx;
      dot.y += dot.vy;

      if (dot.x < 0 || dot.x > width) dot.vx *= -1;
      if (dot.y < 0 || dot.y > height) dot.vy *= -1;

      ctx.beginPath();
      ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#00e0ff";
      ctx.fill();

      // draw lines to nearby dots
      for (let j = i + 1; j < dots.length; j++) {
        const other = dots[j];
        const dx = dot.x - other.x;
        const dy = dot.y - other.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 120) {
          ctx.beginPath();
          ctx.moveTo(dot.x, dot.y);
          ctx.lineTo(other.x, other.y);
          ctx.strokeStyle = "rgba(0,255,255,0.07)";
          ctx.stroke();
        }
      }

      // connect to mouse/touch
      const mdx = dot.x - mouseX;
      const mdy = dot.y - mouseY;
      const mdist = Math.sqrt(mdx * mdx + mdy * mdy);
      if (mdist < 150) {
        ctx.beginPath();
        ctx.moveTo(dot.x, dot.y);
        ctx.lineTo(mouseX, mouseY);
        ctx.strokeStyle = "rgba(0,255,255,0.1)";
        ctx.stroke();
      }
    });
    requestAnimationFrame(animate);
  }

  canvas.addEventListener("pointermove", e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  });

  window.addEventListener("resize", () => {
    resizeCanvas();
    animate();
  });

  resizeCanvas();
  initDots();
  animate();
</script>

</body>
</html>
